<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html>
<!-- Copied from https://htdp.org/2003-09-26/Solutions/local-prag-eval.html by Cyotek WebCopy 1.8.0.652, 01 July 2020, 17:43:44 -->
<head>
<title>Exercise 18.1.6; How to Design Programs </title>
</head>
<body>
<a href="sem-local1.html">18.1.5</a> | <a href="../Book/curriculum-Z-H-23.html#node_thm_18.1.6">Problem Statement</a>
 | <a href="contents.html">Table of Contents</a>
 | <a href="move-pic-local.html">18.1.7</a><pre>;; Language: Intermediate Student

#| 18.1.6 evaluate sort by hand
------------------------------------------------------------
Note: sort has a built-in meaning and cannot be re-defined
so I have renamed the function to mysort
|#
;; mysort : list-of-numbers  -&gt;  list-of-numbers
(define (mysort alon)
  (local ((define (mysort alon)
            (cond
              [(empty? alon) empty]
              [(cons? alon) (insert (first alon)
                                    (mysort (rest alon)))]))
          (define (insert an alon)
            (cond
              [(empty? alon) (list an)]
              [else (cond
                      [(&gt; an (first alon)) (cons an alon)]
                      [else (cons (first alon) 
                                  (insert an (rest alon)))])])))
    (mysort alon)))
(mysort (list 2 1 3))
;-----------------------------------------------------------

(local ((define (mysort alon)
          (cond
            [(empty? alon) empty]
            [(cons? alon) (insert (first alon)
                                  (mysort (rest alon)))]))
        (define (insert an alon)
          (cond
            [(empty? alon) (list an)]
            [else (cond
                    [(&gt; an (first alon)) (cons an alon)]
                    [else (cons (first alon) 
                                (insert an (rest alon)))])])))
  (mysort (list 2 1 3)))
;-----------------------------------------------------------

(local ((define (mysort_0 alon)
          (cond
            [(empty? alon) empty]
            [(cons? alon) (insert_0 (first alon)
                                  (mysort_0 (rest alon)))]))
        (define (insert_0 an alon)
          (cond
            [(empty? alon) (list an)]
            [else (cond
                    [(&gt; an (first alon)) (cons an alon)]
                    [else (cons (first alon) 
                                (insert_0 an (rest alon)))])])))
  (mysort_0 (list 2 1 3)))
;-----------------------------------------------------------

(define (mysort_0 alon)
  (cond
    [(empty? alon) empty]
    [(cons? alon) (insert_0 (first alon)
                            (mysort_0 (rest alon)))]))
(define (insert_0 an alon)
  (cond
    [(empty? alon) (list an)]
    [else (cond
            [(&gt; an (first alon)) (cons an alon)]
            [else (cons (first alon) 
                        (insert_0 an (rest alon)))])]))
(mysort_0 (list 2 1 3))
;-----------------------------------------------------------

(cond
  [(empty? (list 2 1 3)) empty]
  [(cons? (list 2 1 3)) (insert_0 (first (list 2 1 3))
                                  (mysort_0 (rest (list 2 1 3))))])


;****************************************************************

(equal? (mysort (list 1)) (mysort (list 2)))
;-----------------------------------------------------------

(equal? 
 (local ((define (mysort alon)
           (cond
             [(empty? alon) empty]
             [(cons? alon) (insert (first alon)
                                   (mysort (rest alon)))]))
         (define (insert an alon)
           (cond
             [(empty? alon) (list an)]
             [else (cond
                     [(&gt; an (first alon)) (cons an alon)]
                     [else (cons (first alon) 
                                 (insert an (rest alon)))])])))
   (mysort (list 1))) 
 (mysort (list 2)))
;-----------------------------------------------------------

(equal? 
 (local ((define (mysort_1 alon)
           (cond
             [(empty? alon) empty]
             [(cons? alon) (insert_1 (first alon)
                                   (mysort_1 (rest alon)))]))
         (define (insert_1 an alon)
           (cond
             [(empty? alon) (list an)]
             [else (cond
                     [(&gt; an (first alon)) (cons an alon)]
                     [else (cons (first alon) 
                                 (insert_1 an (rest alon)))])])))
   (mysort_1 (list 1))) 
 (mysort (list 2)))
;-----------------------------------------------------------

(define (mysort_1 alon)
  (cond
    [(empty? alon) empty]
    [(cons? alon) (insert_1 (first alon)
                            (mysort_1 (rest alon)))]))
(define (insert_1 an alon)
  (cond
    [(empty? alon) (list an)]
    [else (cond
            [(&gt; an (first alon)) (cons an alon)]
            [else (cons (first alon) 
                        (insert_0 an (rest alon)))])]))
(equal?  (mysort_1 (list 1)) 
         (mysort (list 2)))
;-----------------------------------------------------------

(equal? 
 (cond
   [(empty? (list 1)) empty]
   [(cons? (list 1)) (insert_1 (first (list 1))
                               (mysort_1 (rest (list 1))))])
 (mysort (list 2)))


</pre>
</body>
<!-- Copied from https://htdp.org/2003-09-26/Solutions/local-prag-eval.html by Cyotek WebCopy 1.8.0.652, 01 July 2020, 17:43:44 -->
</html>

<html>
<!-- Copied from https://htdp.org/2003-09-26/Problems/Solutions/sol15.html by Cyotek WebCopy 1.8.0.652, 01 July 2020, 17:43:44 --><head><title>HtDP Solution Set</title></head><body bgcolor="white"><br><table width="100%"><tr><td align="left"><h3>HtDP Solution Set</h3></td><td align="right"><h3>Section 15</h3></td></tr></table><pre><br>#|<br>Leaf nodes are strings representing the common name of the animal.<br><br>A T-node (taxonomy node) is one of<br>  Level or<br>  empty<br><br>A Level is a structure<br>  (make-level string type list-of-t-node)<br>|#<br>(define-struct level (type name children))<br>#|<br>A type is one of<br>  'kingdom<br>  'phylum<br>  'class<br>  'order<br>  'family<br>  'genus<br>  'species<br><br>A list-of-t-node is one of<br>  empty<br>  (cons T-node list-of-t-node)<br>  <br>A list-of-string is one of<br>   empty<br>   (cons string list-of-string)<br>|#  <br><br></pre><p><hr><a name="PROBLEM1"><font color="red">Problem 1 (Solution): </font></a><blockquote><pre>&nbsp;<br>&nbsp;<br></pre></blockquote><p><hr><a name="PROBLEM2"><font color="red">Problem 2 (Solution): </font></a><blockquote><pre>;  return list of child-names of a particular type starting a node<br>(define (child-names atype atnode)<br>  (cond<br>    [(string? atnode) empty]<br>    [(level? atnode)<br>     (cond<br>       [(symbol=? atype (level-type atnode))<br>        (list-children (level-children atnode))]<br>       [else (child-names-lotn atype (level-children atnode))])]))<br>&nbsp;<br>&nbsp;<br>;child-names-lotn : Type List-of-T-node -&gt; List-of-String<br>;  return list of child-names of a particular type in a list of nodes<br>(define (child-names-lotn atype lotn)<br>  (cond<br>    [(empty? lotn) empty]<br>    [else<br>     (append (child-names atype (first lotn))<br>             (child-names-lotn atype (rest lotn)))]))<br>&nbsp;<br>;list-children : List-of-T-node -&gt; List-of-String<br>;  given a List-of-T-node, return list of names of top-level nodes<br>(define (list-children lotn)<br>  (cond<br>    [(empty? lotn) empty]<br>    [else (cons (level-name (first lotn))<br>                (list-children (rest lotn)))]))<br>&nbsp;<br>(define l1 (make-level 'kingdom "animalia" (list (make-level 'phylum "mesozoa" empty)<br>                                     (make-level 'phylum "eumetazoa" empty))))<br>(define l2<br>  (make-level 'kingdom "animalia"<br>    (list (make-level 'genus "homo"<br>            (list (make-level 'species "sapien" empty)<br>                  (make-level 'species "habilis" empty)<br>                  (make-level 'species "erectus" empty))))))<br>&nbsp;<br>(child-names 'kingdom l1)<br>"should be"<br>(list "mesozoa" "eumetazoa")<br>&nbsp;<br>(child-names 'phylum l1)<br>"should be"<br>empty<br>&nbsp;<br></pre></blockquote><p><hr><a name="PROBLEM3"><font color="red">Problem 3 (Solution): </font></a><blockquote><pre>(define (is-classified? atype name atnode)<br>  (cond<br>    [(empty? atnode) false]<br>    [else<br>     (cond<br>       [(and (symbol=? atype (level-type atnode))<br>             (string=? name (level-name atnode)))<br>        true]<br>       [else (is-classified-lotn atype name (level-children atnode))])]))<br>&nbsp;<br>;is-classified-lotn : Type String List-of-T-node -&gt; Boolean<br>(define (is-classified-lotn atype name lotn)<br>  (cond<br>    [(empty? lotn) false]<br>    [else<br>     (or (is-classified? atype name (first lotn))<br>         (is-classified-lotn atype name (rest lotn)))]))<br>&nbsp;<br>&nbsp;<br>(is-classified? 'phylum "eumetazoa" l1)<br>"should be"<br>true<br>(is-classified? 'kingdom "plantae" l1)<br>"should be"<br>false<br>&nbsp;<br></pre></blockquote><p><hr><a name="PROBLEM4"><font color="red">Problem 4 (Solution): </font></a><blockquote><pre>;  given name of type and T-node, return type if match or false<br>(define (get-type name atnode)<br>  (cond<br>    [(empty? atnode) false]<br>    [else<br>     (cond<br>       [(string=? name (level-name atnode)) (level-type atnode)]<br>       [else <br>        (cond<br>          [(boolean? (get-type-lotn name (level-children atnode)))<br>           false]<br>          [else (get-type-lotn name (level-children atnode))])])]))<br>&nbsp;<br>&nbsp;<br>;get-type-lotn : String List-of-T-node -&gt; Symbol or false<br>; given name of type and list of T-nodes, return type if match or false<br>(define (get-type-lotn name lotn)<br>  (cond<br>    [(empty? lotn) false]<br>    [else <br>     (cond<br>       [(boolean? (get-type name (first lotn)))<br>        (get-type-lotn name (rest lotn))]<br>       [else (get-type name (first lotn))])]))<br>&nbsp;<br>&nbsp;<br>(get-type "animalia" l1) "should be" 'kingdom<br>(get-type "eumetazoa" l1) "should be" 'phylum<br>(get-type "brachae" l1) "should be" false<br>&nbsp;<br>&nbsp;<br></pre></blockquote><p><hr><a name="PROBLEM5"><font color="red">Problem 5 (Solution): </font></a><blockquote><pre>; given a type and T-node, return list of names associated with type<br>(define (get-all-of-type atype atnode)<br>  (cond<br>   [(empty? atnode) empty]<br>   [else<br>    (cond<br>     [(symbol=? (level-type atnode) atype)<br>      (cons (level-name atnode)<br>	    (get-all-of-type-lotn atype (level-children atnode)))]<br>     [else (get-all-of-type-lotn atype (level-children atnode))])]))<br>&nbsp;<br>;get-all-of-type-lotn : Type List-of-T-node -&gt; (listof String)<br>; given a type and list of T-nodes, return list of all names associated with type<br>(define (get-all-of-type-lotn atype alotn)<br>  (cond<br>   [(empty? alotn) empty]<br>   [else<br>    (append<br>     (get-all-of-type atype (first alotn))<br>     (get-all-of-type-lotn atype (rest alotn)))]))<br>&nbsp;<br>(get-all-of-type 'species empty)<br>"should be" empty<br>(get-all-of-type 'species l2)<br>"should be" (list "sapien" "habilis" "erectus")<br>&nbsp;<br></pre></blockquote><p><hr><a name="PROBLEM6"><font color="red">Problem 6 (Solution): </font></a><blockquote><pre>;  return list of all species names associated with type and name in a T-node<br>(define (get-species-under-type atype name atnode)<br>  (cond<br>    [(empty? atnode) empty]<br>    [else<br>     (cond<br>       [(and<br>         (symbol=? atype (level-type atnode))<br>         (string=? name (level-name atnode)))<br>        (get-all-of-type 'species atnode)]<br>       [else<br>        (get-species-under-type-lotn atype name (level-children atnode))])]))<br>&nbsp;<br>;get-species-under-type-lotn : Type String List-of-T-node -&gt; (listof String)<br>; return list of all species names associated with type and name in a List-of-T-node<br>(define (get-species-under-type-lotn atype name alotn)<br>  (cond<br>   [(empty? alotn) empty]<br>   [else<br>    (append (get-species-under-type atype name (first alotn))<br>	    (get-species-under-type-lotn atype name (rest alotn)))]))<br>&nbsp;<br>&nbsp;<br>(get-species-under-type 'kingdom "animalia" empty)<br>"should be" empty<br>&nbsp;<br>(get-species-under-type 'kingdom "animalia" l2)<br>"should be" (list "sapien" "habilis" "erectus")<br>&nbsp;<br>(get-species-under-type 'kingdom "plantae" l2)<br>"should be" empty<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br></pre></blockquote><br><hr><table width="90%"><tr><td align="left"><address><a href="../../../cdn-cgi/l/email-protection.html#5d2f3c24303233391d3e3e2e7333382873383928">Jamie Raymond</a></address></td><td align="right"><address>Matthias Felleisen</address></td></tr><tr><td align="left">&nbsp;</td><td align="right"><p>23 september 2002 </p></td></tr></table><script data-cfasync="false" src="../../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body><!-- Copied from https://htdp.org/2003-09-26/Problems/Solutions/sol15.html by Cyotek WebCopy 1.8.0.652, 01 July 2020, 17:43:44 -->
</html>